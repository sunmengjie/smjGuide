<table>
    <tr>
        <td>分类</td>      
        <td>解释</td>          
        <td>举例</td>
    </tr>
    <tr>
        <td>创建型设计模式（Creational）</td>      
        <td>这类设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用新的运算符直接实例化对象，这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活</td>          
        <td>工厂方法模式（Factory Method Pattern）、抽象工厂模式（Abstract Factory Pattern）、单例模式（Singleton Pattern）、原型模式（Prototype Pattern）、建造者模式（Builder Pattern）</td>
    </tr>
    <tr>
        <td>结构型设计模式（Structural）</td>      
        <td>这类设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式</td>          
        <td>代理模式（Proxy Pattern）、门面模式（Facade Pattern）、装饰器模式（Decorator Pattern）、享元模式（Flyweight Pattern）、组合模式（Composite Pattern）、适配器模式（Adapter Pattern）、桥接模式（Bridge Pattern）</td>
    </tr>
    <tr>
        <td>行为型设计模式（Behavioral）</td>      
        <td>这类设计模式特别关注对象之间的通信</td>          
        <td>模板方法模式（Template Method Pattern）、策略模式（Strategy Pattern）、责任链模式（Chain of Responsibility Pattern）、迭代器模式（Iterator Pattern）、命令模式（Command Pattern）、状态模式（State Pattern）、备忘录模式（Memento Pattern）、中介者模式（Mediator Pattern）、解释器模式（Interpreter Pattern）、观察者模式（Observer Pattern）、访问者模式（Visitor Pattern）</td>
    </tr>
</table>




## [为什么要学设计模式](https://juejin.cn/post/7024518374537297933)
- 写出优雅的代码 
- 更好地重构项目 (jdbc -> 简单orm框架）
- 经典框架都在用设计模式解决问题

# 以下设计模式内容均来自《设计模式就该这样学》 
# 以下内容大纲 https://juejin.cn/post/7024471065485115423 
## 创建型设计模式
## 0.[简单工厂模式](https://juejin.cn/post/7028817075422527524)
- 使用简单工厂模式封装产品创建细节
- 简单工厂模式在JDK源码中的应用 Calendar
- 简单工厂模式在Logback源码中的应用

## 1.[工厂方法模式](https://juejin.cn/post/7029167977542975496)
- 工厂方法模式的应用场景
- 工厂方法模式的UML类图
- 工厂方法模式的通用写法
- 使用工厂方法模式实现产品扩展
- 工厂方法模式在Logback源码中的应用

## 2.[抽象工厂模式](https://juejin.cn/post/7029553744333242375)
- 关于产品等级结构和产品族
- 抽象工厂模式的通用写法
- 使用抽象工厂模式支持产品扩展
- 使用抽象工厂模式重构数据库连接池
- 抽象工厂模式在Spring源码中的应用 BeanFactory

## 3.[单例模式](https://juejin.cn/post/7023264146690932773)

单例模式（singleton pattern）是指确保一个类在任何情况下都绝对只有一个实例，并提供一个全局访问点。  隐藏其所有的构造方法

- 通用单例写法带来的弊端
- 还原线程破坏单例的事故现场
- 双重检查锁单例写法闪亮登场
- 看似完美的静态内部类单例写法
- 还原反射破坏单例的事故现场
- 更加优雅的枚举式单例写法问世
- 还原反序列化破坏单例的事故现场
- 还原克隆破坏单例的事故现场
- 容器式单例写法解决大规模生产单例的问题
- 附彩蛋：ThreadLocal线程单例

## 4.[原型模式](https://juejin.cn/post/7025906258351751181)

- 分析JDK浅克隆API带来的问题
- 使用序列化实现深克隆
- 
## 5.[建造者模式](https://juejin.cn/post/7024026719120490527)
- 建造者模式的链式写法
- 使用静态内部类实现建造者模式
- 使用建造者模式动态构建SQL语句 
  - 类似开源框架JPA的SQL构造模式 
  - 如mybatisPlus中的QueryWapper.eq("","") 仅需添加查询条件无需考虑sql拼装

## 结构型设计模式
## 6.[代理模式](https://juejin.cn/post/7023414343962198030)

- 从静态代理到动态代理
- 三层架构中的静态代理
- 使用动态代理实现无感知切换数据源
- 手写JDK动态代理核心原理 JDK动态代理采用字节重组，重新生成对象来替代原始对象，以达到动态代理的目的
  - 获取被代理对象的引用，并且获取它的所有接口，反射获取。
  - JDK动态代理类重新生成一个新的类，同时新的类要实现被代理类实现的所有接口。
  - 动态生成Java代码，新加的业务逻辑方法由一定的逻辑代码调用（在代码中体现）。
  - 编译新生成的Java代码.class文件。
  - 重新加载到JVM中运行
- CGLib动态代理API原理分析 （木有看懂）
- CGLib和JDK Proxy对比分析

## 7.[门面模式](https://juejin.cn/post/7029921654738255886)
- 使用门面模式整合已知API的功能 (facade 层)
- 门面模式在Spring源码中的应用
- 门面模式在MyBatis源码中的应用
- 门面模式在Tomcat源码中的应用

## 8.[装饰器模式](https://juejin.cn/post/7025517932885049357)
也叫包装模式（Wrapper Pattern）
```xml
装饰器（Decorator）模式的定义：
        指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。
装饰器模式的主要优点有：
装饰器是继承的有力补充，比继承灵活，在不改变原有对象的情况下，动态的给一个对象扩展功能，即插即用
通过使用不用装饰类及这些装饰类的排列组合，可以实现不同效果
装饰器模式完全遵守开闭原则

其主要缺点是：装饰器模式会增加许多子类，过度使用会增加程序得复杂性。
```
- 使用装饰器模式解决煎饼加码问题
- 使用装饰器模式扩展日志格式输出

## 9.[享元模式](https://juejin.cn/post/7025622079386943525)
```xml
享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。
        这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。
享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。
        我们将通过创建 5 个对象来画出 20 个分布于不同位置的圆来演示这种模式。由于只有 5 种可用的颜色，
        所以 color 属性被用来检查现有的 Circle 对象。
```
## 10.[组合模式](https://juejin.cn/post/7026575295733825572)
```xml
组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。
        组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。
这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。
```
- 使用透明组合模式实现课程目录结构
- 使用安全组合模式实现无限级文件系统

## 11.[适配器模式](https://juejin.cn/post/7026213515979407397) 
```xml
适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。

这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。
        您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。
```
- 使用类适配器重构第三方登录自由适配
- 使用接口适配器优化代码

## 12.[桥接模式](https://juejin.cn/post/7028107177860530212)
```xml
桥接模式是将抽象部分与它的实现部分分离，使它们都可以独立地变化。
        它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(interface)模式。
```
- 使用桥接模式设计复杂的消息系统 

# 行为设计模式
## 13.[委派模式 delegate pattern](https://juejin.cn/post/7028417041249861669)
```xml
委派模式又叫委托模式，是一种面向对象的设计模式，允许对象组合实现与继承相同的代码重用，
        它的作用就是负责任务的调用和分配。是一种特殊的静态代理，可以理解为全权代理，但是代理模式注重过程，
        而委派模式注重结果，委派模式属于行为型模式，不属于GOF23种设计模式。
```
- 使用委派模式模拟任务分配场景
- 委派模式在JDK源码中的应用
- 委派模式在Spring源码中的应用

## 14.[模板方法模式Template Method Pattern](https://juejin.cn/post/7027762409796304909#heading-1)
```xml
模板方法模式通常又叫模板模式，是指定义一个算法的骨架，并允许子类为其中的一个或多个步骤提供实现。
模板方法是的子类可以在不改变算法结构的情况下，重新定义算法的某些步骤。
属于行为型模式。
```
- 模板方法模式中的钩子方法
- 使用模板方法模式重构JDBC业务操作

## 15.[策略模式](https://juejin.cn/post/7026969491703595022)
```xml
策略模式又叫政策模式，它是将定义的算法家族、分别封装起来，让他们之间可以互相替换，从而让算法
的变化不会影响到使用算法的用户。

可以避免多重分支的if... else... 和switch语句

属于行为模式。
```
- 使用策略模式实现促销优惠方案选择
- 使用策略模式重构支付方式选择场景

## 16.[责任链模式](https://juejin.cn/post/7023691352223252488)
```xml
责任链模式是一种设计模式。在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成
        一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客
        户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况
        下动态地重新组织和分配责任。   from 百度百科
```
- 使用责任链模式设计热插拔权限控制
- 责任链模式和建造者模式结合使用

## 17.[迭代器模式](https://juejin.cn/post/7030669050178961415)
```xml
在面向对象编程里，迭代器模式是一种设计模式，是一种最简单也最常见的设计模式。它可以让用户透过特定的接口巡访容器中的每一个元素而不用了解底层的实现。
此外，也可以实现特定目的版本的迭代器。
```
- 手写自定义的集合迭代器
- 迭代器模式在JDK源码中的应用
- 迭代器模式在MyBatis源码中的应用

## 18.[命令模式](https://juejin.cn/post/7033314264106565668)
```xml
命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的
        合适的对象，并把该命令传给相应的对象，该对象执行命令。
```
- 命令模式的UML类图
- 使用命令模式重构播放器控制条
- 命令模式在JDK源码中的应用
- 命令模式在JUnit源码中的应用

## 19.[状态模式](https://juejin.cn/post/7024471065485115423)
```xml
状态模式也叫状态机模式
当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。
状态模式主要解决的是当控制一个对象状态的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类中，可以把复杂的判断逻辑简化。
```
- 状态模式的UML类图
- 使用状态模式实现登录状态自由切换
- 使用状态机实现订单状态流转控制
  - Spring也提供了一个很好的解决方案。Spring中的组件名称就叫作状态机（StateMachine）。状态机帮助开发者简化状态控制的开发过程，让状态机结构更加层次化。下面用Spring状态机模拟一个订单状态流转的过程。
```java
<dependency>
    <groupId>org.springframework.statemachine</groupId>
    <artifactId>spring-statemachine-core</artifactId>
    <version>2.0.1.RELEASE</version>
</dependency>
```

## 20.[备忘录模式](https://juejin.cn/post/7033642409175187493)
```java
备忘录模式是一种软件设计模式：在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。
        这样以后就可将该对象恢复到原先保存的状态。
```
- 使用备忘录模式实现草稿箱功能
- 备忘录模式在Spring源码中的应用
## 21.[中介者模式](https://juejin.cn/post/7034007164142223374)
```xml
一种设计模式。用一个中介对象来封装一系列对象的交互，从而把一批原来可能是交互关系复杂的对象转换成一组松散耦合的
        中间对象，以有利于维护和修改。
```
- 中介者模式的应用场景
- 中介者模式的UML类图
- 使用中介者模式设计群聊场景
- 中介者模式在JDK源码中的应用

## 22.[解释器模式](https://juejin.cn/post/7031803439642312712)
```xml
解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接
        口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。
```
- 使用解释器模式解析数学表达式
- 解释器模式在JDK源码中的应用
- 解释器模式在Spring源码中的应用

## 23.[观察者模式](https://juejin.cn/post/7031443755513151496)
```xml
观察者模式（有时又被称为模型（Model）-视图（View）模式、源-收听者(Listener)模式或从属者模式）是软件设计模式的
        一种。在此种模式中，一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。这通常
        透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实现事件处理系统。
```
- 基于Java API实现通知机制
- 基于Guava API轻松落地观察者模式
- 使用观察者模式设计鼠标事件响应API


## 24.[访问者模式](https://juejin.cn/post/7034029915943108615)
```xml
访问者模式是一种将数据结构与数据操作分离的设计模式。是指封装一些作用于某种数据结构中的各元素的操作
特征：可以在不改变数据结构的亲体下定义作用于这些元素的新操作。
属于行为模式
```
- 使用访问者模式实现KPI考核的场景
- 从静态分派到动态分派
- 访问者模式中的伪动态分派
- 访问者模式在JDK源码中的应用
- 访问者模式在Spring源码中的应用